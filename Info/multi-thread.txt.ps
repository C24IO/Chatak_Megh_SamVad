%!PS-Adobe-3.0
%%Title: multi-thread.txt
%%For: root
%%Creator: a2ps version 4.13
%%CreationDate: Sun Mar 27 21:01:28 2005
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 12
%%PageOrder: Ascend
%%DocumentMedia: Letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Define these in case they're not in the FontInfo (also, here
    % they're easier to get to.
    /UnderlinePosition 1 def
    /UnderlineThickness 1 def
    
    % Get the underline position and thickness if they're defined.
    currentdict /FontInfo known {
      FontInfo
      
      dup /UnderlinePosition known {
	dup /UnderlinePosition get
	0 exch FontMatrix transform exch pop
	/UnderlinePosition exch def
      } if
      
      dup /UnderlineThickness known {
	/UnderlineThickness get
	0 exch FontMatrix transform exch pop
	/UnderlineThickness exch def
      } if
      
    } if
    currentdict 
  end 
} bind def

% composite fonts for ASCII-EUC mixed strings
% Version 1.2 1/31/1990
% Original Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.493857 def
/cw 4.496314 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   522.321860 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
([LUPG Home <http://www.actcom.co.il/~choo/lupg/index.html>] [Tutorials) N
(<http://www.actcom.co.il/~choo/lupg/tutorials/index.html>] [Related) N
(Material <http://www.actcom.co.il/~choo/lupg/related-material.html>]) N
([Essays <http://www.actcom.co.il/~choo/lupg/essays/index.html>] [Project) N
(Ideas <http://www.actcom.co.il/~choo/lupg/project-ideas/index.html>]) N
([Send Comments <mailto:choo@actcom.co.il>]) N
() N
(v1.2) N
() N
() N
(  Multi-Threaded Programming With POSIX Threads) N
() N
(Table Of Contents:) N
() N
(   1. Before We Start... <#preface>) N
(   2. What Is a Thread? Why Use Threads? <#definition>) N
(   3. Creating And Destroying Threads <#thread_create_stop>) N
(   4. Synchronizing Threads With Mutexes <#thread_mutex>) N
(         1. What Is A Mutex? <#thread_mutex_whatis>) N
(         2. Creating And Initializing A Mutex <#thread_mutex_creation>) N
(         3. Locking And Unlocking A Mutex <#thread_mutex_lock_unlock>) N
(         4. Destroying A Mutex <#thread_mutex_destroy>) N
(         5. Using A Mutex - A Complete Example) N
(            <#thread_mutex_complete_example>) N
(         6. Starvation And Deadlock Situations) N
(            <#thread_mutex_starvation_deadlock> ) N
(   5. Refined Synchronization - Condition Variables <#thread_condvar>) N
(         1. What Is A Condition Variable? <#thread_condvar_whatis>) N
(         2. Creating And Initializing A Condition Variable) N
(            <#thread_condvar_creation>) N
(         3. Signaling A Condition Variable <#thread_condvar_signal>) N
(         4. Waiting On A Condition Variable <#thread_condvar_wait>) N
(         5. Destroying A Condition Variable <#thread_condvar_destroy>) N
(         6. A Real Condition For A Condition Variable) N
(            <#thread_condvar_condition>) N
(         7. Using A Condition Variable - A Complete Example) N
(            <#thread_condvar_example> ) N
(   6. "Private" thread data - Thread-Specific Data <#thread_tss>) N
(         1. Overview Of Thread-Specific Data Support <#thread_tss_overview>) N
(         2. Allocating Thread-Specific Data Block <#thread_tss_create>) N
(         3. Accessing Thread-Specific Data <#thread_tss_access>) N
(         4. Deleting Thread-Specific Data Block <#thread_tss_delete>) N
(         5. A Complete Example <#thread_tss_example> ) N
(   7. Thread Cancellation And Termination <#thread_cancel>) N
(         1. Canceling A Thread <#thread_cancel_cancel>) N
(         2. Setting Thread Cancellation State <#thread_cancel_setstate>) N
(         3. Cancellation Points <#thread_cancel_points>) N
(         4. Setting Thread Cleanup Functions <#thread_cancel_cleanup>) N
(         5. Synchronizing On Threads Exiting <#thread_cancel_join>) N
(         6. Detaching A Thread <#thread_cancel_detach>) N
(         7. Threads Cancellation - A Complete Example) N
(            <#thread_cancel_example> ) N
(   8. Using Threads For Responsive User Interface Programming) N
(      <#thread_user_interface>) N
(         1. User Interaction - A Complete Example) N
(            <#thread_user_interface_example> ) N
(   9. Using 3rd-Party Libraries In A Multi-Threaded Application) N
(      <#thread_3rd_party>) N
(  10. Using A Threads-Aware Debugger <#thread_debugger> ) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    Before We Start...) N
() N
(This tutorial is an attempt to help you become familiar with) N
(multi-threaded programming with the POSIX threads \(pthreads\) library,) N
(and attempts to show how its features can be used in "real-life") N
(multi-thread.txt) (Page 1/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(programs. It explains the different tools defined by the library, shows) p n
(how to use them, and then gives an example of using them to solve) N
(programming problems. There is an implicit assumption that the user has) N
(some theoretical familiarity with paralell programming \(or) N
(multi-processing\) concepts. Users without such background might find the) N
(concepts harder to grasp. A seperate tutorial will be prepared to) N
(explain the theoreticl background and terms to those who are familiar) N
(only with normal "serial" programming.) N
() N
(I would assume that users which are familiar with asynchronous) N
(programming models, such as those used in windowing environments \(X,) N
(Motif\), will find it easier to grasp the concepts of multi-threaded) N
(programming.) N
() N
(When talking about POSIX threads, one cannot avoid the question "Which) N
(draft of the POSIX threads standard shall be used?". As this threads) N
(standard has been revised over a period of several years, one will find) N
(that implementations adhering to different drafts of the standard have a) N
(different set of functions, different default values, and different) N
(nuances. Since this tutorial was written using a Linux system with the) N
(kernel-level LinuxThreads library, v0.5, programmers with access to) N
(other systems, using different versions of pthreads, should refer to) N
(their system's manuals in case of incompatibilities. Also, since some of) N
(the example programs are using blocking system calls, they won't work) N
(with user-level threading libraries \(refer to our parallel programming) N
(theory tutorial) N
(<http://www.actcom.co.il/~choo/lupg/tutorials/parallel-programming-theory/parall) N
(el-programming-theory.html#multi_thread_lib>) N
(for more information\).) N
(Having said that, i'd try to check the example programs on other systems) N
(as well \(Solaris 2.5 comes to mind\), to make it more "cross-platform".) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    What Is a Thread? Why Use Threads) N
() N
(A thread is a semi-process, that has its own stack, and executes a given) N
(piece of code. Unlike a real process, the thread normally shares its) N
(memory with other threads \(where as for processes we usually have a) N
(different memory area for each one of them\). A Thread Group is a set of) N
(threads all executing inside the same process. They all share the same) N
(memory, and thus can access the same global variables, same heap memory,) N
(same set of file descriptors, etc. All these threads execute in parallel) N
(\(i.e. using time slices, or if the system has several processors, then) N
(really in parallel\).) N
() N
(The advantage of using a thread group instead of a normal serial program) N
(is that several operations may be carried out in parallel, and thus) N
(events can be handled immediately as they arrive \(for example, if we) N
(have one thread handling a user interface, and another thread handling) N
(database queries, we can execute a heavy query requested by the user,) N
(and still respond to user input while the query is executed\).) N
() N
(The advantage of using a thread group over using a process group is that) N
(context switching between threads is much faster than context switching) N
(between processes \(context switching means that the system switches from) N
(running one thread or process, to running another thread or process\).) N
(Also, communications between two threads is usually faster and easier to) N
(implement than communications between two processes.) N
() N
(On the other hand, because threads in a group all use the same memory) N
(space, if one of them corrupts the contents of its memory, other threads) N
(might suffer as well. With processes, the operating system normally) N
(protects processes from one another, and thus if one corrupts its own) N
(memory space, other processes won't suffer. Another advantage of using) N
(processes is that they can run on different machines, while all the) N
(threads have to run on the same machine \(at least normally\).) N
() N
(multi-thread.txt) (Page 2/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (1/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(------------------------------------------------------------------------) p n
() N
() N
(    Creating And Destroying Threads) N
() N
(When a multi-threaded program starts executing, it has one thread) N
(running, which executes the main\(\) function of the program. This is) N
(already a full-fledged thread, with its own thread ID. In order to) N
(create a new thread, the program should use the |_pthread_create\(\)_|) N
(function. Here is how to use it:) N
() N
(------------------------------------------------------------------------) N
() N
(|) N
(#include <stdio.h>       /* standard I/O routines                 */) N
(#include <pthread.h>     /* pthread functions and data structures */) N
() N
(/* function to be executed by the new thread */) N
(void*) N
(do_loop\(void* data\)) N
({) N
(    int i;) S 16 T () S 24 T () S 32 T (/* counter, to print numbers */) N
(    int j;) S 16 T () S 24 T () S 32 T (/* counter, for delay        */) N
(    int me = *\(\(int*\)data\);     /* thread identifying number */) N
() N
(    for \(i=0; i<10; i++\) {) N
() S 8 T (for \(j=0; j<500000; j++\) /* delay loop */) N
() S 8 T (    ;) N
(        printf\("'%d' - Got '%d'\\n", me, i\);) N
(    }) N
() N
(    /* terminate the thread */) N
(    pthread_exit\(NULL\);) N
(}) N
() N
(/* like any C program, program's execution begins in main */) N
(int) N
(main\(int argc, char* argv[]\)) N
({) N
(    int        thr_id;         /* thread ID for the newly created thread */) N
(    pthread_t  p_thread;       /* thread's structure                     */) N
(    int        a         = 1;  /* thread 1 identifying number            */) N
(    int        b         = 2;  /* thread 2 identifying number            */) N
() N
(    /* create a new thread that will execute 'do_loop\(\)' */) N
(    thr_id = pthread_create\(&p_thread, NULL, do_loop, \(void*\)&a\);) N
(    /* run 'do_loop\(\)' in the main thread as well */) N
(    do_loop\(\(void*\)&b\);) N
(    ) N
(    /* NOT REACHED */) N
(    return 0;) N
(}) N
(|) N
() N
(------------------------------------------------------------------------) N
() N
(A few notes should be mentioned about this program:) N
() N
(   1. Note that the main program is also a thread, so it executes the) N
(      |do_loop\(\)| function in parallel to the thread it creates.) N
(   2. |pthread_create\(\)| gets 4 parameters. The first parameter is used) N
(      by |pthread_create\(\)| to supply the program with information about) N
(      the thread. The second parameter is used to set some attributes) N
(      for the new thread. In our case we supplied a NULL pointer to tell) N
(      |pthread_create\(\)| to use the default values. The third parameter) N
(      is the name of the function that the thread will start executing.) N
(      The forth parameter is an argument to pass to this function. Note) N
(      the cast to a 'void*'. It is not required by ANSI-C syntax, but is) N
(      placed here for clarification.) N
(multi-thread.txt) (Page 3/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   3. The delay loop inside the function is used only to demonstrate) p n
(      that the threads are executing in parallel. Use a larger delay) N
(      value if your CPU runs too fast, and you see all the printouts of) N
(      one thread before the other.) N
(   4. The call to |_pthread_exit\(\)_| Causes the current thread to exit) N
(      and free any thread-specific resources it is taking. There is no) N
(      need to use this call at the end of the thread's top function,) N
(      since when it returns, the thread would exit automatically anyway.) N
(      This function is useful if we want to exit a thread in the middle) N
(      of its execution. ) N
() N
(In order to compile a multi-threaded program using |_gcc_|, we need to) N
(link it with the pthreads library. Assuming you have this library) N
(already installed on your system, here is how to compile our first program:) N
() N
(| gcc pthread_create.c -o pthread_create -lpthread |) N
() N
(Note that for some of the programs later on this tutorial, one may need) N
(to add a '-D_GNU_SOURCE' flag to this compile line, to get the source) N
(compiled.) N
() N
(The source code for this program may be found in the pthread_create.c file.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    Synchronizing Threads With Mutexes) N
() N
(One of the basic problems when running several threads that use the same) N
(memory space, is making sure they don't "step on each other's toes". By) N
(this we refer to the problem of using a data structure from two) N
(different threads.) N
() N
(For instance, consider the case where two threads try to update two) N
(variables. One tries to set both to 0, and the other tries to set both) N
(to 1. If both threads would try to do that at the same time, we might) N
(get with a situation where one variable contains 1, and one contains 0.) N
(This is because a context-switch \(we already know what this is by now,) N
(right?\) might occur after the first tread zeroed out the first variable,) N
(then the second thread would set both variables to 1, and when the first) N
(thread resumes operation, it will zero out the second variable, thus) N
(getting the first variable set to '1', and the second set to '0'.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        What Is A Mutex?) N
() N
(A basic mechanism supplied by the pthreads library to solve this) N
(problem, is called a mutex. A mutex is a lock that guarantees three things:) N
() N
(   1. _Atomicity_ - Locking a mutex is an atomic operation, meaning that) N
(      the operating system \(or threads library\) assures you that if you) N
(      locked a mutex, no other thread succeeded in locking this mutex at) N
(      the same time.) N
(   2. _Singularity_ - If a thread managed to lock a mutex, it is assured) N
(      that no other thread will be able to lock the thread until the) N
(      original thread releases the lock.) N
(   3. _Non-Busy Wait_ - If a thread attempts to lock a thread that was) N
(      locked by a second thread, the first thread will be suspended \(and) N
(      will not consume any CPU resources\) until the lock is freed by the) N
(      second thread. At this time, the first thread will wake up and) N
(      continue execution, having the mutex locked by it. ) N
() N
(From these three points we can see how a mutex can be used to assure) N
(exclusive access to variables \(or in general critical code sections\).) N
(Here is some pseudo-code that updates the two variables we were talking) N
(about in the previous section, and can be used by the first thread:) N
() N
(multi-thread.txt) (Page 4/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (2/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(lock mutex 'X1'.) p n
(set first variable to '0'.) N
(set second variable to '0'.) N
(unlock mutex 'X1'.) N
() N
() N
() N
(Meanwhile, the second thread will do something like this:) N
() N
(lock mutex 'X1'.) N
(set first variable to '1'.) N
(set second variable to '1'.) N
(unlock mutex 'X1'.) N
() N
() N
() N
(Assuming both threads use the same mutex, we are assured that after they) N
(both ran through this code, either both variables are set to '0', or) N
(both are set to '1'. You'd note this requires some work from the) N
(programmer - If a third thread was to access these variables via some) N
(code that does not use this mutex, it still might mess up the variable's) N
(contents. Thus, it is important to enclose all the code that accesses) N
(these variables in a small set of functions, and always use only these) N
(functions to access these variables.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Creating And Initializing A Mutex) N
() N
(In order to create a mutex, we first need to declare a variable of type) N
(|pthread_mutex_t|, and then initialize it. The simplest way it by) N
(assigning it the |PTHREAD_MUTEX_INITIALIZER| constant. So we'll use a) N
(code that looks something like this:) N
() N
(|) N
(pthread_mutex_t a_mutex = PTHREAD_MUTEX_INITIALIZER;) N
(|) N
() N
() N
() N
(One note should be made here: This type of initialization creates a) N
(mutex called 'fast mutex'. This means that if a thread locks the mutex) N
(and then tries to lock it again, it'll get stuck - it will be in a) N
(deadlock.) N
() N
(There is another type of mutex, called 'recursive mutex', which allows) N
(the thread that locked it, to lock it several more times, without) N
(getting blocked \(but other threads that try to lock the mutex now will) N
(get blocked\). If the thread then unlocks the mutex, it'll still be) N
(locked, until it is unlocked the same amount of times as it was locked.) N
(This is similar to the way modern door locks work - if you turned it) N
(twice clockwise to lock it, you need to turn it twice counter-clockwise) N
(to unlock it. This kind of mutex can be created by assigning the) N
(constant |PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP| to a mutex variable.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Locking And Unlocking A Mutex) N
() N
(In order to lock a mutex, we may use the function) N
(|pthread_mutex_lock\(\)|. This function attempts to lock the mutex, or) N
(block the thread if the mutex is already locked by another thread. In) N
(this case, when the mutex is unlocked by the first process, the function) N
(will return with the mutex locked by our process. Here is how to lock a) N
(mutex \(assuming it was initialized earlier\):) N
() N
(|) N
(multi-thread.txt) (Page 5/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(int rc = pthread_mutex_lock\(&a_mutex\);) p n
(if \(rc\) { /* an error has occurred */) N
(    perror\("pthread_mutex_lock"\);) N
(    pthread_exit\(NULL\);) N
(}) N
(/* mutex is now locked - do your stuff. */) N
(.) N
(.) N
(|) N
() N
() N
() N
(After the thread did what it had to \(change variables or data) N
(structures, handle file, or whatever it intended to do\), it should free) N
(the mutex, using the |pthread_mutex_unlock\(\)| function, like this:) N
() N
(|) N
(rc = pthread_mutex_unlock\(&a_mutex\);) N
(if \(rc\) {) N
(    perror\("pthread_mutex_unlock"\);) N
(    pthread_exit\(NULL\);) N
(}) N
(|) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Destroying A Mutex) N
() N
(After we finished using a mutex, we should destroy it. Finished using) N
(means no thread needs it at all. If only one thread finished with the) N
(mutex, it should leave it alive, for the other threads that might still) N
(need to use it. Once all finished using it, the last one can destroy it) N
(using the |pthread_mutex_destroy\(\)| function:) N
() N
(|) N
(rc = pthread_mutex_destroy\(&a_mutex\);) N
(|) N
() N
() N
() N
(After this call, this variable \(a_mutex\) may not be used as a mutex any) N
(more, unless it is initialized again. Thus, if one destroys a mutex too) N
(early, and another thread tries to lock or unlock it, that thread will) N
(get a |EINVAL| error code from the lock or unlock function.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Using A Mutex - A Complete Example) N
() N
(After we have seen the full life cycle of a mutex, lets see an example) N
(program that uses a mutex. The program introduces two employees) N
(competing for the "employee of the day" title, and the glory that comes) N
(with it. To simulate that in a rapid pace, the program employs 3) N
(threads: one that promotes Danny to "employee of the day", one that) N
(promotes Moshe to that situation, and a third thread that makes sure) N
(that the employee of the day's contents is consistent \(i.e. contains) N
(exactly the data of one employee\).) N
(Two copies of the program are supplied. One that uses a mutex, and one) N
(that does not. Try them both, to see the differences, and be convinced) N
(that mutexes are essential in a multi-threaded environment.) N
() N
(The programs themselves are in the files accompanying this tutorial. The) N
(one that uses a mutex is employee-with-mutex.c. The one that does not) N
(use a mutex is employee-without-mutex.c. Read the comments inside the) N
(source files to get a better understanding of how they work.) N
() N
(------------------------------------------------------------------------) N
(multi-thread.txt) (Page 6/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (3/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(        Starvation And Deadlock Situations) N
() N
(Again we should remember that |pthread_mutex_lock\(\)| might block for a) N
(non-determined duration, in case of the mutex being already locked. If) N
(it remains locked forever, it is said that our poor thread is "starved") N
(- it was trying to acquire a resource, but never got it. It is up to the) N
(programmer to ensure that such starvation won't occur. The pthread) N
(library does not help us with that.) N
() N
(The pthread library might, however, figure out a "deadlock". A deadlock) N
(is a situation in which a set of threads are all waiting for resources) N
(taken by other threads, all in the same set. Naturally, if all threads) N
(are blocked waiting for a mutex, none of them will ever come back to) N
(life again. The pthread library keeps track of such situations, and thus) N
(would fail the last thread trying to call |pthread_mutex_lock\(\)|, with) N
(an error of type |EDEADLK|. The programmer should check for such a) N
(value, and take steps to solve the deadlock somehow.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    Refined Synchronization - Condition Variables) N
() N
(As we've seen before with mutexes, they allow for simple coordination -) N
(exclusive access to a resource. However, we often need to be able to) N
(make real synchronization between threads:) N
() N
(    * In a server, one thread reads requests from clients, and) N
(      dispatches them to several threads for handling. These threads) N
(      need to be notified when there is data to process, otherwise they) N
(      should wait without consuming CPU time.) N
(    * In a GUI \(Graphical User Interface\) Application, one thread reads) N
(      user input, another handles graphical output, and a third thread) N
(      sends requests to a server and handles its replies. The) N
(      server-handling thread needs to be able to notify the) N
(      graphics-drawing thread when a reply from the server arrived, so) N
(      it will immediately show it to the user. The user-input thread) N
(      needs to be always responsive to the user, for example, to allow) N
(      her to cancel long operations currently executed by the) N
(      server-handling thread. ) N
() N
(All these examples require the ability to send notifications between) N
(threads. This is where condition variables are brought into the picture.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        What Is A Condition Variable?) N
() N
(A condition variable is a mechanism that allows threads to wait \(without) N
(wasting CPU cycles\) for some even to occur. Several threads may wait on) N
(a condition variable, until some other thread signals this condition) N
(variable \(thus sending a notification\). At this time, one of the threads) N
(waiting on this condition variable wakes up, and can act on the event.) N
(It is possible to also wake up all threads waiting on this condition) N
(variable by using a broadcast method on this variable.) N
() N
(Note that a condition variable does not provide locking. Thus, a mutex) N
(is used along with the condition variable, to provide the necessary) N
(locking when accessing this condition variable.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Creating And Initializing A Condition Variable) N
() N
(Creation of a condition variable requires defining a variable of type) N
(multi-thread.txt) (Page 7/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(|pthread_cond_t|, and initializing it properly. Initialization may be) p n
(done with either a simple use of a macro named) N
(|PTHREAD_COND_INITIALIZER| or the usage of the |pthread_cond_init\(\)|) N
(function. We will show the first form here:) N
() N
(| pthread_cond_t got_request = PTHREAD_COND_INITIALIZER; |) N
() N
(This defines a condition variable named 'got_request', and initializes it.) N
() N
(/Note: since the |PTHREAD_COND_INITIALIZER| is actually a structure) N
(initializer, it may be used to initialize a condition variable only when) N
(it is declared. In order to initialize it during runtime, one must use) N
(the |pthread_cond_init\(\)| function. /) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Signaling A Condition Variable) N
() N
(In order to signal a condition variable, one should either the) N
(|pthread_cond_signal\(\)| function \(to wake up a only one thread waiting) N
(on this variable\), or the |pthread_cond_broadcast\(\)| function \(to wake) N
(up all threads waiting on this variable\). Here is an example using) N
(signal, assuming 'got_request' is a properly initialized condition) N
(variable:) N
() N
(| int rc = pthread_cond_signal\(&got_request\); |) N
() N
(Or by using the broadcast function:) N
() N
(| int rc = pthread_cond_broadcast\(&got_request\); |) N
() N
(When either function returns, 'rc' is set to 0 on success, and to a) N
(non-zero value on failure. In such a case \(failure\), the return value) N
(denotes the error that occured \(|EINVAL| denotes that the given) N
(parameter is not a condition variable. |ENOMEM| denotes that the system) N
(has run out of memory.) N
() N
(/Note: success of a signaling operation does not mean any thread was) N
(awakened - it might be that no thread was waiting on the condition) N
(variable, and thus the signaling does nothing \(i.e. the signal is lost\).) N
(It is also not remembered for future use - if after the signaling) N
(function returns another thread starts waiting on this condition) N
(variable, a further signal is required to wake it up. /) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Waiting On A Condition Variable) N
() N
(If one thread signals the condition variable, other threads would) N
(probably want to wait for this signal. They may do so using one of two) N
(functions, |pthread_cond_wait\(\)| or |pthread_cond_timedwait\(\)|. Each of) N
(these functions takes a condition variable, and a mutex \(which should be) N
(locked before calling the wait function\), unlocks the mutex, and waits) N
(until the condition variable is signaled, suspending the thread's) N
(execution. If this signaling causes the thread to awake \(see discussion) N
(of |pthread_cond_signal\(\)| earlier\), the mutex is automagically locked) N
(again by the wait funciton, and the wait function returns.) N
() N
(The only difference between these two functions is that) N
(|pthread_cond_timedwait\(\)| allows the programmer to specify a timeout) N
(for the waiting, after which the function always returns, with a proper) N
(error value \(ETIMEDOUT\) to notify that condition variable was NOT) N
(signaled before the timeout passed. The |pthread_cond_wait\(\)| would wait) N
(indefinitely if it was never signaled.) N
() N
(Here is how to use these two functions. We make the assumption that) N
('got_request' is a properly initialized condition variable, and that) N
(multi-thread.txt) (Page 8/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (4/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
('request_mutex' is a properly initialized mutex. First, we try the) p n
(|pthread_cond_wait\(\)| function:) N
() N
(|) N
(/* first, lock the mutex */) N
(int rc = pthread_mutex_lock\(&request_mutex\);) N
(if \(rc\) { /* an error has occurred */) N
(    perror\("pthread_mutex_lock"\);) N
(    pthread_exit\(NULL\);) N
(}) N
(/* mutex is now locked - wait on the condition variable.             */) N
(/* During the execution of pthread_cond_wait, the mutex is unlocked. */) N
(rc = pthread_cond_wait\(&got_request, &request_mutex\);) N
(if \(rc == 0\) { /* we were awakened due to the cond. variable being signaled */) N
(               /* The mutex is now locked again by pthread_cond_wait\(\)      */) N
(    /* do your stuff... */) N
(    .) N
(}) N
(/* finally, unlock the mutex */) N
(pthread_mutex_unlock\(&request_mutex\);) N
(|) N
() N
() N
() N
(Now an example using the |pthread_cond_timedwait\(\)| function:) N
() N
(|) N
(#include <sys/time.h>     /* struct timeval definition           */) N
(#include <unistd.h>       /* declaration of gettimeofday\(\)       */) N
() N
(struct timeval  now;            /* time when we started waiting        */) N
(struct timespec timeout;        /* timeout value for the wait function */) N
(int             done;           /* are we done waiting?                */) N
() N
(/* first, lock the mutex */) N
(int rc = pthread_mutex_lock\(&a_mutex\);) N
(if \(rc\) { /* an error has occurred */) N
(    perror\("pthread_mutex_lock"\);) N
(    pthread_exit\(NULL\);) N
(}) N
(/* mutex is now locked */) N
() N
(/* get current time */ ) N
(gettimeofday\(&now\);) N
(/* prepare timeout value.              */) N
(/* Note that we need an absolute time. */) N
(timeout.tv_sec = now.tv_sec + 5) N
(timeout.tv_nsec = now.tv_usec * 1000; /* timeval uses micro-seconds.         */) N
(                                      /* timespec uses nano-seconds.         */) N
(                                      /* 1 micro-second = 1000 nano-seconds. */) N
() N
(/* wait on the condition variable. */) N
(/* we use a loop, since a Unix signal might stop the wait before the timeout */) N
(done = 0;) N
(while \(!done\) {) N
(    /* remember that pthread_cond_timedwait\(\) unlocks the mutex on entrance */) N
(    rc = pthread_cond_timedwait\(&got_request, &request_mutex, &timeout\);) N
(    switch\(rc\) {) N
(        case 0:  /* we were awakened due to the cond. variable being signaled */) N
(                 /* the mutex was now locked again by pthread_cond_timedwait. */) N
(            /* do your stuff here... */) N
(            .) N
(            .) N
(            done = 0;) N
(            break;) N
(        default:        /* some error occurred \(e.g. we got a Unix signal\) */) N
(            if \(errno == ETIMEDOUT\) { /* our time is up */) N
(                done = 0;) N
(            }) N
(multi-thread.txt) (Page 9/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            break;      /* break this switch, but re-do the while loop.   */) p n
(    }) N
(}) N
(/* finally, unlock the mutex */) N
(pthread_mutex_unlock\(&request_mutex\);) N
(|) N
() N
() N
() N
(As you can see, the timed wait version is way more complex, and thus) N
(better be wrapped up by some function, rather than being re-coded in) N
(every necessary location.) N
() N
(/Note: it might be that a condition variable that has 2 or more threads) N
(waiting on it is signaled many times, and yet one of the threads waiting) N
(on it never awakened. This is because we are not guaranteed which of the) N
(waiting threads is awakened when the variable is signaled. It might be) N
(that the awakened thread quickly comes back to waiting on the condition) N
(variables, and gets awakened again when the variable is signaled again,) N
(and so on. The situation for the un-awakened thread is called) N
('starvation'. It is up to the programmer to make sure this situation) N
(does not occur if it implies bad behavior. Yet, in our server example) N
(from before, this situation might indicate requests are coming in a very) N
(slow pace, and thus perhaps we have too many threads waiting to service) N
(requests. In this case, this situation is actually good, as it means) N
(every request is handled immediately when it arrives. /) N
() N
(/Note 2: when the mutex is being broadcast \(using) N
(pthread_cond_broadcast\), this does not mean all threads are running) N
(together. Each of them tries to lock the mutex again before returning) N
(from their wait function, and thus they'll start running one by one,) N
(each one locking the mutex, doing their work, and freeing the mutex) N
(before the next thread gets its chance to run. /) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Destroying A Condition Variable) N
() N
(After we are done using a condition variable, we should destroy it, to) N
(free any system resources it might be using. This can be done using the) N
(|pthread_cond_destroy\(\)|. In order for this to work, there should be no) N
(threads waiting on this condition variable. Here is how to use this) N
(function, again, assuming 'got_request' is a pre-initialized condition) N
(variable:) N
() N
(|) N
(int rc = pthread_cond_destroy\(&got_request\);) N
(if \(rc == EBUSY\) { /* some thread is still waiting on this condition variable */) N
(    /* handle this case here... */) N
(    .) N
(    .) N
(}) N
(|) N
() N
() N
() N
(What if some thread is still waiting on this variable? depending on the) N
(case, it might imply some flaw in the usage of this variable, or just) N
(lack of proper thread cleanup code. It is probably good to alert the) N
(programmer, at least during debug phase of the program, of such a case.) N
(It might mean nothing, but it might be significant.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        A Real Condition For A Condition Variable) N
() N
(A note should be taken about condition variables - they are usually) N
(multi-thread.txt) (Page 10/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (5/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(pointless without some real condition checking combined with them. To) p n
(make this clear, lets consider the server example we introduced earlier.) N
(Assume that we use the 'got_request' condition variable to signal that a) N
(new request has arrived that needs handling, and is held in some) N
(requests queue. If we had threads waiting on the condition variable when) N
(this variable is signaled, we are assured that one of these threads will) N
(awake and handle this request.) N
() N
(However, what if all threads are busy handling previous requests, when a) N
(new one arrives? the signaling of the condition variable will do nothing) N
(\(since all threads are busy doing other things, NOT waiting on the) N
(condition variable now\), and after all threads finish handling their) N
(current request, they come back to wait on the variable, which won't) N
(necessarily be signaled again \(for example, if no new requests arrive\).) N
(Thus, there is at least one request pending, while all handling threads) N
(are blocked, waiting for a signal.) N
() N
(In order to overcome this problem, we may set some integer variable to) N
(denote the number of pending requests, and have each thread check the) N
(value of this variable before waiting on the variable. If this) N
(variable's value is positive, some request is pending, and the thread) N
(should go and handle it, instead of going to sleep. Further more, a) N
(thread that handled a request, should reduce the value of this variable) N
(by one, to make the count correct.) N
(Lets see how this affects the waiting code we have seen above.) N
() N
(------------------------------------------------------------------------) N
() N
(|) N
(/* number of pending requests, initially none */) N
(int num_requests = 0;) N
(.) N
(.) N
(/* first, lock the mutex */) N
(int rc = pthread_mutex_lock\(&request_mutex\);) N
(if \(rc\) { /* an error has occurred */) N
(    perror\("pthread_mutex_lock"\);) N
(    pthread_exit\(NULL\);) N
(}) N
(/* mutex is now locked - wait on the condition variable */) N
(/* if there are no requests to be handled.              */) N
(rc = 0;) N
(if \(num_requests == 0\)) N
(    rc = pthread_cond_wait\(&got_request, &request_mutex\);) N
(if \(num_requests > 0 && rc == 0\) { /* we have a request pending */) N
(        /* unlock mutex - so other threads would be able to handle */) N
(        /* other reqeusts waiting in the queue paralelly.          */) N
(        rc = pthread_mutex_unlock\(&request_mutex\);) N
(        /* do your stuff... */) N
(        .) N
(        .) N
(        /* decrease count of pending requests */) N
(        num_requests--;) N
(        /* and lock the mutex again - to remain symmetrical,. */) N
(        rc = pthread_mutex_lock\(&request_mutex\);) N
(    }) N
(}) N
(/* finally, unlock the mutex */) N
(pthread_mutex_unlock\(&request_mutex\);) N
(|) N
() N
(------------------------------------------------------------------------) N
(------------------------------------------------------------------------) N
() N
() N
(        Using A Condition Variable - A Complete Example) N
() N
(As an example for the actual usage of condition variables, we will show) N
(a program that simulates the server we have described earlier - one) N
(multi-thread.txt) (Page 11/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(thread, the receiver, gets client requests. It inserts the requests to a) p n
(linked list, and a hoard of threads, the handlers, are handling these) N
(requests. For simplicity, in our simulation, the receiver thread creates) N
(requests and does not read them from real clients.) N
() N
(The program source is available in the file thread-pool-server.c, and) N
(contains many comments. Please read the source file first, and then read) N
(the following clarifying notes.) N
() N
(   1. The 'main' function first launches the handler threads, and then) N
(      performs the chord of the receiver thread, via its main loop.) N
(   2. A single mutex is used both to protect the condition variable, and) N
(      to protect the linked list of waiting requests. This simplifies) N
(      the design. As an exercise, you may think how to divide these) N
(      roles into two mutexes.) N
(   3. The mutex itself MUST be a recursive mutex. In order to see why,) N
(      look at the code of the 'handle_requests_loop' function. You will) N
(      notice that it first locks the mutex, and afterwards calls the) N
(      'get_request' function, which locks the mutex again. If we used a) N
(      non-recursive mutex, we'd get locked indefinitely in the mutex) N
(      locking operation of the 'get_request' function.) N
(      You may argue that we could remove the mutex locking in the) N
(      'get_request' function, and thus remove the double-locking) N
(      problem, but this is a flawed design - in a larger program, we) N
(      might call the 'get_request' function from other places in the) N
(      code, and we'll need to check for proper locking of the mutex in) N
(      each of them.) N
(   4. As a rule, when using recursive mutexes, we should try to make) N
(      sure that each lock operation is accompanied by a matching unlock) N
(      operation in the same function. Otherwise, it will be very hard to) N
(      make sure that after locking the mutex several times, it is being) N
(      unlocked the same number of times, and deadlocks would occur.) N
(   5. The implicit unlocking and re-locking of the mutex on the call to) N
(      the |pthread_cond_wait\(\)| function is confusing at first. It is) N
(      best to add a comment regarding this behavior in the code, or else) N
(      someone that reads this code might accidentally add a further) N
(      mutex lock.) N
(   6. When a handler thread handles a request - it should free the) N
(      mutex, to avoid blocking all the other handler threads. After it) N
(      finished handling the request, it should lock the mutex again, and) N
(      check if there are more requests to handle. ) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    "Private" thread data - Thread-Specific Data) N
() N
(In "normal", single-thread programs, we sometimes find the need to use a) N
(global variable. Ok, so good old teach' told us it is bad practice to) N
(have global variables, but they sometimes do come handy. Especially if) N
(they are static variables - meaning, they are recognized only on the) N
(scope of a single file.) N
() N
(In multi-threaded programs, we also might find a need for such) N
(variables. We should note, however, that the same variable is accessible) N
(from all the threads, so we need to protect access to it using a mutex,) N
(which is extra overhead. Further more, we sometimes need to have a) N
(variable that is 'global', but only for a specific thread. Or the same) N
('global' variable should have different values in different threads. For) N
(example, consider a program that needs to have one globally accessible) N
(linked list in each thread, but note the same list. Further, we want the) N
(same code to be executed by all threads. In this case, the global) N
(pointer to the start of the list should be point to a different address) N
(in each thread.) N
() N
(In order to have such a pointer, we need a mechanism that enables the) N
(same global variable to have a different location in memory. This is) N
(what the thread-specific data mechanism is used for.) N
() N
(multi-thread.txt) (Page 12/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (6/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(------------------------------------------------------------------------) p n
() N
() N
(        Overview Of Thread-Specific Data Support) N
() N
(In the thread-specific data \(TSD\) mechanism, we have notions of keys and) N
(values. Each key has a name, and pointer to some memory area. Keys with) N
(the same name in two separate threads always point to different memory) N
(locations - this is handled by the library functions that allocate) N
(memory blocks to be accessed via these keys. We have a function to) N
(create a key \(invoked once per key name for the whole process\), a) N
(function to allocate memory \(invoked separately in each thread\), and) N
(functions to de-allocate this memory for a specific thread, and a) N
(function to destroy the key, again, process-wide. we also have functions) N
(to access the data pointed to by a key, either setting its value, or) N
(returning the value it points to.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Allocating Thread-Specific Data Block) N
() N
(The |pthread_key_create\(\)| function is used to allocate a new key. This) N
(key now becomes valid for all threads in our process. When a key is) N
(created, the value it points to defaults to NULL. Later on each thread) N
(may change its copy of the value as it wishes. Here is how to use this) N
(function:) N
() N
(|) N
(/* rc is used to contain return values of pthread functions */) N
(int rc;) N
(/* define a variable to hold the key, once created.         */) N
(pthread_key_t list_key;) N
(/* cleanup_list is a function that can clean up some data   */) N
(/* it is specific to our program, not to TSD                */) N
(extern void* cleanup_list\(void*\);) N
() N
(/* create the key, supplying a function that'll be invoked when it's deleted. */) N
(rc = pthread_key_create\(&list_key, cleanup_list\);) N
(|) N
() N
() N
() N
(Some notes:) N
() N
(   1. After |pthread_key_create\(\)| returns, the variable 'list_key') N
(      points to the newly created key.) N
(   2. The function pointer passed as second parameter to) N
(      |pthread_key_create\(\)|, will be automatically invoked by the) N
(      pthread library when our thread exits, with a pointer to the key's) N
(      value as its parameter. We may supply a NULL pointer as the) N
(      function pointer, and then no function will be invoked for key.) N
(      Note that the function will be invoked once in each thread, even) N
(      thought we created this key only once, in one thread.) N
(      If we created several keys, their associated destructor functions) N
(      will be called in an arbitrary order, regardless of the order of) N
(      keys creation.) N
(   3. If the |pthread_key_create\(\)| function succeeds, it returns 0.) N
(      Otherwise, it returns some error code.) N
(   4. There is a limit of |PTHREAD_KEYS_MAX| keys that may exist in our) N
(      process at any given time. An attempt to create a key after) N
(      |PTHREAD_KEYS_MAX| exits, will cause a return value of EAGAIN from) N
(      the |pthread_key_create\(\)| function. ) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Accessing Thread-Specific Data) N
() N
(multi-thread.txt) (Page 13/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(After we have created a key, we may access its value using two pthread) p n
(functions: |pthread_getspecific\(\)| and |pthread_setspecific\(\)|. The) N
(first is used to get the value of a given key, and the second is used to) N
(set the data of a given key. A key's value is simply a void pointer) N
(\(void*\), so we can store in it anything that we want. Lets see how to) N
(use these functions. We assume that 'a_key' is a properly initialized) N
(variable of type |pthread_key_t| that contains a previously created key:) N
() N
(------------------------------------------------------------------------) N
() N
(|) N
(/* this variable will be used to store return codes of pthread functions */) N
(int rc;) N
() N
(/* define a variable into which we'll store some data */) N
(/* for example, and integer.                          */) N
(int* p_num = \(int*\)malloc\(sizeof\(int\)\);) N
(if \(!p_num\) {) N
(    fprintf\(stderr, "malloc: out of memory\\n";) N
(    exit\(1\);) N
(}) N
(/* initialize our variable to some value */) N
(\(*p_num\) = 4;) N
() N
(/* now lets store this value in our TSD key.    */) N
(/* note that we don't store 'p_num' in our key. */) N
(/* we store the value that p_num points to.     */) N
(rc = pthread_setspecific\(a_key, \(void*\)p_num\);) N
() N
(.) N
(.) N
(/* and somewhere later in our code... */) N
(.) N
(.) N
(/* get the value of key 'a_key' and print it. */) N
({) N
(    int* p_keyval = \(int*\)pthread_getspecific\(a_key\);) N
() N
(    if \(p_keyval != NULL\) {) N
() S 8 T (printf\("value of 'a_key' is: %d\\n", *p_keyval\);) N
(    }) N
(}) N
(|) N
() N
(------------------------------------------------------------------------) N
() N
(Note that if we set the value of the key in one thread, and try to get) N
(it in another thread, we will get a NULL, since this value is distinct) N
(for each thread.) N
() N
(Note also that there are two cases where |pthread_getspecific\(\)| might) N
(return NULL:) N
() N
(   1. The key supplied as a parameter is invalid \(e.g. its key wasn't) N
(      created\).) N
(   2. The value of this key is NULL. This means it either wasn't) N
(      initialized, or was set to NULL explicitly by a previous call to) N
(      |pthread_setspecific\(\)|. ) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Deleting Thread-Specific Data Block) N
() N
(The |pthread_key_delete\(\)| function may be used to delete keys. But do) N
(not be confused by this function's name: it does not delete memory) N
(associated with this key, nor does it call the destructor function) N
(defined during the key's creation. Thus, you still need to do memory) N
(cleanup on your own if you need to free this memory during runtime.) N
(multi-thread.txt) (Page 14/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (7/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(However, since usage of global variables \(and thus also thread-specific) p n
(data\), you usually don't need to free this memory until the thread) N
(terminate, in which case the pthread library will invoke your destructor) N
(functions anyway.) N
() N
(Using this function is simple. Assuming list_key is a |pthread_key_t|) N
(variable pointing to a properly created key, use this function like this:) N
() N
(| int rc = pthread_key_delete\(key\); |) N
() N
(the function will return 0 on success, or EINVAL if the supplied) N
(variable does not point to a valid TSD key.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        A Complete Example) N
() N
(None yet. Give me a while to think of one...... sorry. All i can think) N
(of right now is 'global variables are evil'. I'll try to find a good) N
(example for the future. If you have a good example, please let me know.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    Thread Cancellation And Termination) N
() N
(As we create threads, we need to think about terminating them as well.) N
(There are several issues involved here. We need to be able to terminate) N
(threads cleanly. Unlike processes, where a very ugly method of using) N
(signals is used, the folks that designed the pthreads library were a) N
(little more thoughtful. So they supplied us with a whole system of) N
(canceling a thread, cleaning up after a thread, and so on. We will) N
(discuss these methods here.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Canceling A Thread) N
() N
(When we want to terminate a thread, we can use the |pthread_cancel|) N
(function. This function gets a thread ID as a parameter, and sends a) N
(cancellation request to this thread. What this thread does with this) N
(request depends on its state. It might act on it immediately, it might) N
(act on it when it gets to a cancellation point \(discussed below\), or it) N
(might completely ignore it. We'll see later how to set the state of a) N
(thread and define how it acts on cancellation requests. Lets first see) N
(how to use the cancel function. We assume that 'thr_id' is a variable of) N
(type |pthread_id| containing the ID of a running thread:) N
() N
(|) N
(pthread_cancel\(thr_id\);) N
(|) N
() N
() N
() N
(The |pthread_cancel\(\)| function returns 0, so we cannot know if it) N
(succeeded or not.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Setting Thread Cancellation State) N
() N
(A thread's cancel state may be modified using several methods. The first) N
(is by using the |pthread_setcancelstate\(\)| function. This function) N
(defines whether the thread will accept cancellation requests or not. The) N
(function takes two arguments. One that sets the new cancel state, and) N
(one into which the previous cancel state is stored by the function. Here) N
(multi-thread.txt) (Page 15/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(is how it is used:) p n
() N
(|) N
(int old_cancel_state;) N
(pthread_setcancelstate\(PTHREAD_CANCEL_DISABLE, &old_cancel_state\);) N
(|) N
() N
() N
() N
(This will disable canceling this thread. We can also enable canceling) N
(the thread like this:) N
() N
(|) N
(int old_cancel_state;) N
(pthread_setcancelstate\(PTHREAD_CANCEL_ENABLE, &old_cancel_state\);) N
(|) N
() N
() N
() N
(Note that you may supply a NULL pointer as the second parameter, and) N
(then you won't get the old cancel state.) N
() N
(A similar function, named |pthread_setcanceltype\(\)| is used to define) N
(how a thread responds to a cancellation request, assuming it is in the) N
('ENABLED' cancel state. One option is to handle the request immediately) N
(\(asynchronously\). The other is to defer the request until a cancellation) N
(point. To set the first option \(asynchronous cancellation\), do something) N
(like:) N
() N
(|) N
(int old_cancel_type;) N
(pthread_setcanceltype\(PTHREAD_CANCEL_ASYNCHRONOUS, &old_cancel_type\);) N
(|) N
() N
() N
() N
(And to set the second option \(deferred cancellation\):) N
() N
(|) N
(int old_cancel_type;) N
(pthread_setcanceltype\(PTHREAD_CANCEL_DEFERRED, &old_cancel_type\);) N
(|) N
() N
() N
() N
(Note that you may supply a NULL pointer as the second parameter, and) N
(then you won't get the old cancel type.) N
() N
(You might wonder - "What if i never set the cancellation state or type) N
(of a thread?". Well, in such a case, the |pthread_create\(\)| function) N
(automatically sets the thread to enabled deferred cancellation, that is,) N
(|PTHREAD_CANCEL_ENABLE| for the cancel mode, and) N
(|PTHREAD_CANCEL_DEFERRED| for the cancel type.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Cancellation Points) N
() N
(As we've seen, a thread might be in a state where it does not handle) N
(cancel requests immediately, but rather defers them until it reaches a) N
(cancellation point. So what are these cancellation points?) N
() N
(In general, any function that might suspend the execution of a thread) N
(for a long time, should be a cancellation point. In practice, this) N
(depends on the specific implementation, and how conformant it is to the) N
(relevant POSIX standard \(and which version of the standard it conforms) N
(to...\). The following set of pthread functions serve as cancellation) N
(points:) N
(multi-thread.txt) (Page 16/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (8/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (17-18) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    * |pthread_join\(\)|) N
(    * |pthread_cond_wait\(\)|) N
(    * |pthread_cond_timedwait\(\)|) N
(    * |pthread_testcancel\(\)|) N
(    * |sem_wait\(\)|) N
(    * |sigwait\(\)| ) N
() N
(This means that if a thread executes any of these functions, it'll check) N
(for deferred cancel requests. If there is one, it will execute the) N
(cancellation sequence, and terminate. Out of these functions,) N
(|pthread_testcancel\(\)| is unique - it's only purpose is to test whether) N
(a cancellation request is pending for this thread. If there is, it) N
(executes the cancellation sequence. If not, it returns immediately. This) N
(function may be used in a thread that does a lot of processing without) N
(getting into a "natural" cancellation state.) N
() N
(/Note: In real conformant implementations of the pthreads standard,) N
(normal system calls that cause the process to block, such as |read\(\)|,) N
(|select\(\)|, |wait\(\)| and so on, are also cancellation points. The same) N
(goes for standard C library functions that use these system calls \(the) N
(various printf functions, for example\). /) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Setting Thread Cleanup Functions) N
() N
(One of the features the pthreads library supplies is the ability for a) N
(thread to clean up after itself, before it exits. This is done by) N
(specifying one or more functions that will be called automatically by) N
(the pthreads library when the thread exits, either due to its own will) N
(\(e.g. calling |pthread_exit\(\)|\), or due to it being canceled.) N
() N
(Two functions are supplied for this purpose. The) N
(|pthread_cleanup_push\(\)| function is used to add a cleanup function to) N
(the set of cleanup functions for the current thread. The) N
(|pthread_cleanup_pop\(\)| function removes the last function added with) N
(|pthread_cleanup_push\(\)|. When the thread terminates, its cleanup) N
(functions are called in the reverse order of their registration. So the) N
(the last one to be registered is the first one to be called.) N
() N
(When the cleanup functions are called, each one is supplied with one) N
(parameter, that was supplied as the second parameter to the) N
(|pthread_cleanup_push\(\)| function call. Lets see how these functions may) N
(be used. In our example we'll see how these functions may be used to) N
(clean up some memory that our thread allocates when it starts running.) N
() N
(------------------------------------------------------------------------) N
() N
(|) N
() N
(/* first, here is the cleanup function we want to register.        */) N
(/* it gets a pointer to the allocated memory, and simply frees it. */) N
(void) N
(cleanup_after_malloc\(void* allocated_memory\)) N
({) N
(    if \(allocated_memory\)) N
(        free\(allocated_memory\);) N
(}) N
() N
(/* and here is our thread's function.      */) N
(/* we use the same function we used in our */) N
(/* thread-pool server.                     */) N
(void*) N
(handle_requests_loop\(void* data\)) N
({) N
(    .) N
(    .) N
(multi-thread.txt) (Page 17/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    /* this variable will be used later. please read on...         */) p n
(    int old_cancel_type;) N
() N
(    /* allocate some memory to hold the start time of this thread. */) N
(    /* assume MAX_TIME_LEN is a previously defined macro.          */) N
(    char* start_time = \(char*\)malloc\(MAX_TIME_LEN\);) N
() N
(    /* push our cleanup handler. */) N
(    pthread_cleanup_push\(cleanup_after_malloc, \(void*\)start_time\);) N
(    .) N
(    .) N
(    /* here we start the thread's main loop, and do whatever is desired.. */) N
(    .) N
(    .) N
(    .) N
() N
(    /* and finally, we unregister the cleanup handler. our method may seem */) N
(    /* awkward, but please read the comments below for an explanation.     */) N
() N
(    /* put the thread in deferred cancellation mode.      */) N
(    pthread_setcanceltype\(PTHREAD_CANCEL_DEFERRED, &old_cancel_type\);) N
() N
(    /* supplying '1' means to execute the cleanup handler */) N
(    /* prior to unregistering it. supplying '0' would     */) N
(    /* have meant not to execute it.                      */) N
(    pthread_cleanup_pop\(1\);) N
() N
(    /* restore the thread's previous cancellation mode.   */) N
(    pthread_setcanceltype\(old_cancel_type, NULL\);) N
(}) N
(|) N
() N
(------------------------------------------------------------------------) N
() N
(As we can see, we allocated some memory here, and registered a cleanup) N
(handler that will free this memory when our thread exits. After the) N
(execution of the main loop of our thread, we unregistered the cleanup) N
(handler. This must be done in the same function that registered the) N
(cleanup handler, and in the same nesting level, since both) N
(|pthread_cleanup_pop\(\)| and |pthread_cleanup_pop\(\)| functions are) N
(actually macros that add a '{' symbol and a '}' symbol, respectively.) N
() N
(As to the reason that we used that complex piece of code to unregister) N
(the cleanup handler, this is done to assure that our thread won't get) N
(canceled in the middle of the execution of our cleanup handler. This) N
(could have happened if our thread was in asynchronous cancellation mode.) N
(Thus, we made sure it was in deferred cancellation mode, then) N
(unregistered the cleanup handler, and finally restored whatever) N
(cancellation mode our thread was in previously. Note that we still) N
(assume the thread cannot be canceled in the execution of) N
(|pthread_cleanup_pop\(\)| itself - this is true, since) N
(|pthread_cleanup_pop\(\)| is not a cancellation point.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Synchronizing On Threads Exiting) N
() N
(Sometimes it is desired for a thread to wait for the end of execution of) N
(another thread. This can be done using the |pthread_join\(\)| function. It) N
(receives two parameters: a variable of type |pthread_t|, denoting the) N
(thread to be joined, and an address of a |void*| variable, into which) N
(the exit code of the thread will be placed \(or |PTHREAD_CANCELED| if the) N
(joined thread was canceled\).) N
(The |pthread_join\(\)| function suspends the execution of the calling) N
(thread until the joined thread is terminated.) N
() N
(For example, consider our earlier thread pool server. Looking back at) N
(the code, you'll see that we used an odd |sleep\(\)| call before) N
(multi-thread.txt) (Page 18/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (9/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (19-20) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(terminating the process. We did this since the main thread had no idea) p n
(when the other threads finished processing all pending requests. We) N
(could have solved it by making the main thread run a loop of checking if) N
(no more requests are pending, but that would be a busy loop.) N
() N
(A cleaner way of implementing this, is by adding three changes to the code:) N
() N
(   1. Tell the handler threads when we are done creating requests, by) N
(      setting some flag.) N
(   2. Make the threads check, whenever the requests queue is empty,) N
(      whether or not new requests are supposed to be generated. If not,) N
(      then the thread should exit.) N
(   3. Make the main thread wait for the end of execution of each of the) N
(      threads it spawned. ) N
() N
(The first 2 changes are rather easy. We create a global variable named) N
('done_creating_requests' and set it to '0' initially. Each thread checks) N
(the contents of this variable every time before it intends to go to wait) N
(on the condition variable \(i.e. the requests queue is empty\).) N
(The main thread is modified to set this variable to '1' after it) N
(finished generating all requests. Then the condition variable is being) N
(broadcast, in case any of the threads is waiting on it, to make sure all) N
(threads go and check the 'done_creating_requests' flag.) N
() N
(The last change is done using a |pthread_join\(\)| loop: call) N
(|pthread_join\(\)| once for each handler thread. This way, we know that) N
(only after all handler threads have exited, this loop is finished, and) N
(then we may safely terminate the process. If we didn't use this loop, we) N
(might terminate the process while one of the handler threads is still) N
(handling a request.) N
() N
(The modified program is available in the file named) N
(thread-pool-server-with-join.c. Look for the word 'CHANGE' \(in capital) N
(letters\) to see the locations of the three changes.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Detaching A Thread) N
() N
(We have seen how threads can be joined using the |pthread_join\(\)|) N
(function. In fact, threads that are in a 'join-able' state, must be) N
(joined by other threads, or else their memory resources will not be) N
(fully cleaned out. This is similar to what happens with processes whose) N
(parents didn't clean up after them \(also called 'orphan' or 'zombie') N
(processes\).) N
() N
(If we have a thread that we wish would exit whenever it wants without) N
(the need to join it, we should put it in the detached state. This can be) N
(done either with appropriate flags to the |pthread_create\(\)| function,) N
(or by using the |pthread_detach\(\)| function. We'll consider the second) N
(option in our tutorial.) N
() N
(The |pthread_detach\(\)| function gets one parameter, of type |pthread_t|,) N
(that denotes the thread we wish to put in the detached state. For) N
(example, we can create a thread and immediately detach it with a code) N
(similar to this:) N
() N
(|) N
(pthread_t a_thread;   /* store the thread's structure here              */) N
(int rc;               /* return value for pthread functions.            */) N
(extern void* thread_loop\(void*\); /* declare the thread's main function. */) N
() N
(/* create the new thread. */) N
(rc = pthread_create\(&a_thread, NULL, thread_loop, NULL\);) N
() N
(/* and if that succeeded, detach the newly created thread. */) N
(if \(rc == 0\) {) N
(    rc = pthread_detach\(a_thread\);) N
(multi-thread.txt) (Page 19/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
(|) N
() N
() N
() N
(Of-course, if we wish to have a thread in the detached state) N
(immediately, using the first option \(setting the detached state directly) N
(when calling |pthread_create\(\)| is more efficient.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Threads Cancellation - A Complete Example) N
() N
(Our next example is much larger than the previous examples. It) N
(demonstrates how one could write a multi-threaded program in C, in a) N
(more or less clean manner. We take our previous thread-pool server, and) N
(enhance it in two ways. First, we add the ability to tune the number of) N
(handler threads based on the requests load. New threads are created if) N
(the requests queue becomes too large, and after the queue becomes) N
(shorter again, extra threads are canceled.) N
() N
(Second, we fix up the termination of the server when there are no more) N
(new requests to handle. Instead of the ugly sleep we used in our first) N
(example, this time the main thread waits for all threads to finish) N
(handling their last requests, by joining each of them using) N
(|pthread_join\(\)|.) N
() N
(The code is now being split to 4 separate files, as follows:) N
() N
(   1. requests_queue.c <thread-pool-server-changes/requests_queue.c> -) N
(      This file contains functions to manipulate a requests queue. We) N
(      took the |add_request\(\)| and |get_request\(\)| functions and put) N
(      them here, along with a data structure that contains all the) N
(      variables previously defined as globals - pointer to queue's head,) N
(      counter of requests, and even pointers to the queue's mutex and) N
(      condition variable. This way, all the manipulation of the data is) N
(      done in a single file, and all its functions receive a pointer to) N
(      a 'requests_queue' structure.) N
(   2. handler_thread.c <thread-pool-server-changes/handler_thread.c> -) N
(      this contains the functions executed by each handler thread - a) N
(      function that runs the main loop \(an enhanced version of the) N
(      'handle_requests_loop\(\)' function, and a few local functions) N
(      explained below\). We also define a data structure to collect all) N
(      the data we want to pass to each thread. We pass a pointer to such) N
(      a structure as a parameter to the thread's function in the) N
(      |pthread_create\(\)| call, instead of using a bunch of ugly globals:) N
(      the thread's ID, a pointer to the requests queue structure, and) N
(      pointers to the mutex and condition variable to be used.) N
(   3. handler_threads_pool.c) N
(      <thread-pool-server-changes/handler_threads_pool.c> - here we) N
(      define an abstraction of a thread pool. We have a function to) N
(      create a thread, a function to delete \(cancel\) a thread, and a) N
(      function to delete all active handler threads, called during) N
(      program termination. we define here a structure similar to that) N
(      used to hold the requests queue, and thus the functions are) N
(      similar. However, because we only access this pool from one) N
(      thread, the main thread, we don't need to protect it using a) N
(      mutex. This saves some overhead caused by mutexes. the overhead is) N
(      small, but for a busy server, it might begin to become noticeable.) N
(   4. main.c <thread-pool-server-changes/main.c> - and finally, the main) N
(      function to rule them all, and in the system bind them. This) N
(      function creates a requests queue, creates a threads pool, creates) N
(      few handler threads, and then starts generating requests. After) N
(      adding a request to the queue, it checks the queue size and the) N
(      number of active handler threads, and adjusts the number of) N
(      threads to the size of the queue. We use a simple water-marks) N
(      algorithm <#side_notes_watermarks> here, but as you can see from) N
(      the code, it can be easily be replaced by a more sophisticated) N
(multi-thread.txt) (Page 20/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (10/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (21-22) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      algorithm. In our water-marks algorithm implementation, when the) p n
(      high water-mark is reached, we start creating new handler threads,) N
(      to empty the queue faster. Later, when the low water-mark is) N
(      reached, we start canceling the extra threads, until we are left) N
(      with the original number of handler threads. ) N
() N
(After rewriting the program in a more manageable manner, we added code) N
(that uses the newly learned pthreads functions, as follows:) N
() N
(   1. Each handler thread created puts itself in the deferred) N
(      cancellation mode. This makes sure that when it gets canceled, it) N
(      can finish handling its current request, before terminating.) N
(   2. Each handler thread also registers a cleanup function, to unlock) N
(      the mutex when it terminates. This is done, since a thread is most) N
(      likely to get canceled when calling |pthread_cond_wait\(\)|, which) N
(      is a cancellation point. Since the function is called with the) N
(      mutex locked, it might cause the thread to exit and cause all) N
(      other threads to 'hang' on the mutex. Thus, unlocking the mutex in) N
(      a cleanup handler \(registered with the |pthread_cleanup_push\(\)|) N
(      function\) is the proper solution.) N
(   3. Finally, the main thread is set to clean up properly, and not) N
(      brutally, as we did before. When it wishes to terminate, it calls) N
(      the 'delete_handler_threads_pool\(\)' function, which calls) N
(      |pthread_join| for each remaining handler thread. This way, the) N
(      function returns only after all handler threads finished handling) N
(      their last request. ) N
() N
(Please refer to the source code <thread-pool-server-changes> for the) N
(full details. Reading the header files first will make it easier to) N
(understand the design. To compile the program, just switch to the) N
(thread-pool-server-changes directory, and type 'gmake'.) N
() N
(Exercise: our last program contains some possible race condition during) N
(its termination process. Can you see what this race is all about? Can) N
(you offer a complete solution to this problem? \(hint - think of what) N
(happens to threads deleted using 'delete_handler_thread\(\)'\).) N
() N
(Exercise 2: the way we implement the water-marks algorithm might come up) N
(too slow on creation of new threads. Try thinking of a different) N
(algorithm that will shorten the average time a request stays on the) N
(queue until it gets handled. Add some code to measure this time, and) N
(experiment until you find your "optimal pool algorithm". Note - Time) N
(should be measured in very small units \(using the |getrusage| system) N
(call\), and several runs of each algorithm should be made, to get more) N
(accurate measurements.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    Using Threads For Responsive User Interface Programming) N
() N
(One area in which threads can be very helpful is in user-interface) N
(programs. These programs are usually centered around a loop of reading) N
(user input, processing it, and showing the results of the processing.) N
(The processing part may sometimes take a while to complete, and the user) N
(is made to wait during this operation. By placing such long operations) N
(in a seperate thread, while having another thread to read user input,) N
(the program can be more responsive. It may allow the user to cancel the) N
(operation in the middle.) N
() N
(In graphical programs the problem is more severe, since the application) N
(should always be ready for a message from the windowing system telling) N
(it to repaint part of its window. If it's too busy executing some other) N
(task, its window will remain blank, which is rather ugly. In such a) N
(case, it is a good idea to have one thread handle the message loop of) N
(the windowing systm and always ready to get such repain requests \(as) N
(well as user input\). When ever this thread sees a need to do an) N
(operation that might take a long time to complete \(say, more than 0.2) N
(seconds in the worse case\), it will delegate the job to a seperate thread.) N
(multi-thread.txt) (Page 21/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(In order to structure things better, we may use a third thread, to) N
(control and synchronize the user-input and task-performing threads. If) N
(the user-input thread gets any user input, it will ask the controlling) N
(thread to handle the operation. If the task-performing thread finishes) N
(its operation, it will ask the controlling thread to show the results to) N
(the user.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        User Interaction - A Complete Example) N
() N
(As an example, we will write a simple character-mode program that counts) N
(the number of lines in a file, while allowing the user to cancel the) N
(operation in the middle.) N
() N
(Our main thread will launch one thread to perform the line counting, and) N
(a second thread to check for user input. After that, the main thread) N
(waits on a condition variable. When any of the threads finishes its) N
(operation, it signals this condition variable, in order to let the main) N
(thread check what happened. A global variable is used to flag whether or) N
(not a cancel request was made by the user. It is initialized to '0', but) N
(if the user-input thread receives a cancellation request \(the user) N
(pressing 'e'\), it sets this flag to '1', signals the condition variable,) N
(and terminates. The line-counting thread will signal the condition) N
(variable only after it finished its computation.) N
() N
(Before you go read the program, we should explain the use of the) N
(|system\(\)| function and the 'stty' Unix command. The |system\(\)| function) N
(spawns a shell in which it executes the Unix command given as a) N
(parameter. The |stty| Unix command is used to change terminal mode) N
(settings. We use it to switch the terminal from its default,) N
(line-buffered mode, to a character mode \(also known as raw mode\), so the) N
(call to |getchar\(\)| in the user-input thread will return immediatly) N
(after the user presses any key. If we hadn't done so, the system will) N
(buffer all input to the program until the user presses the ENTER key.) N
(Finally, since this raw mode is not very useful \(to say the least\) once) N
(the program terminates and we get the shell prompt again, the user-input) N
(thread registers a cleanup function that restores the normal terminal) N
(mode, i.e. line-buffered. For more info, please refer to stty's manual) N
(page.) N
() N
(The program's source can be found in the file line-count.c. The name of) N
(the file whose lines it reads is hardcoded to 'very_large_data_file'.) N
(You should create a file with this name in the program's directory) N
(\(large enough for the operation to take enough time\). Alternatively, you) N
(may un-compress the file 'very_large_data_file.Z' found in this) N
(directory, using the command:) N
() N
(| uncompress very_large_data_file.Z |) N
() N
(note that this will create a 5MB\(!\) file named 'very_large_data_file',) N
(so make sure you have enough free disk-space before performing this) N
(operation.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    Using 3rd-Party Libraries In A Multi-Threaded Application) N
() N
(One more point, and a very important one, should be taken by programmers) N
(employeeing multi-threading in their programs. Since a multi-threaded) N
(program might have the same function executed by different threads at) N
(the same time, one must make sure that any function that might be) N
(invoked from more than one thread at a time, is MT-safe \(Multi-Thread) N
(Safe\). This means that any access to data structures and other shared) N
(resources is protected using mutexes.) N
() N
(multi-thread.txt) (Page 22/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (11/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (23-24) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(It may be possibe to use a non-MT-safe library in a multi-threaded) p n
(programs in two ways:) N
() N
(   1. _Use this library only from a single thread_. This way we are) N
(      assured that no function from the library is executed) N
(      simultanouasly from two seperate threads. The problem here is that) N
(      it might limit your whole design, and might force you to add more) N
(      communications between threads, if another thread needs to somehow) N
(      use a function from this library.) N
(   2. _Use mutexes to protect function calls to the library_. This means) N
(      that a single mutex is used by any thread invoking any function in) N
(      this library. The mutex is locked, the function is invoked, and) N
(      then the mutex is unlocked. The problem with this solution is that) N
(      the locking is not done in a fine granularity - even if two) N
(      functions from the library do not interfere with each other, they) N
(      still cannot be invoked at the same time by seperate threads. The) N
(      second thread will be blocked on the mutex until the first thread) N
(      finishes the function call. You might call for using seperate) N
(      mutexes for unrelated functions, but usually you've no idea how) N
(      the library really works and thus cannot know which functions) N
(      access the same set of resources. More than that, even if you do) N
(      know that, a new version of the library might behave differently,) N
(      forcing you to modify your whole locking system. ) N
() N
(As you can see, non-MT-safe libraries need special attention, so it is) N
(best to find MT-safe libraries with a similar functionality, if possible.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(    Using A Threads-Aware Debugger) N
() N
(One last thing to note - when debugging a multi-threaded application,) N
(one needs to use a debugger that "sees" the threads in the program. Most) N
(up-to-date debuggers that come with commercial development environments) N
(are thread-aware. As for Linux, gdb as is shiped with most \(all?\)) N
(distributions seems to be not thread-aware. There is a project, called) N
('SmartGDB', that added thread support to gdb, as well as a graphical) N
(user interface \(which is almost a must when debugging multi-threaded) N
(applications\). However, it may be used to debug only multi-threaded) N
(applications that use the various user-level thread libraries. Debugging) N
(LinuxThreads with SmartGDB requires applying some kernel patches, that) N
(are currently available only for Linux kernels from the 2.1.X series.) N
(More information about this tool may be found at) N
(http://hegel.ittc.ukans.edu/projects/smartgdb/. There is also some) N
(information about availability of patches to the 2.0.32 kernel and gdb) N
(4.17. This information may be found on the LinuxThreads homepage) N
(<http://pauillac.inria.fr/~xleroy/linuxthreads/>.) N
() N
(------------------------------------------------------------------------) N
() N
() N
(        Side-Notes) N
() N
(water-marks algorithm) N
(    An algorithm used mostly when handling buffers or queues: start) N
(    filling in the queue. If its size exceeds a threshold, known as the) N
(    high water-mark, stop filling the queue \(or start emptying it) N
(    faster\). Keep this state until the size of the queue becomes lower) N
(    than another threshold, known as the low water-mark. At this point,) N
(    resume the operation of filling the queue \(or return the emptying) N
(    speed to the original speed\). ) N
() N
() N
() N
() N
([LUPG Home <http://www.actcom.co.il/~choo/lupg/index.html>] [Tutorials) N
(<http://www.actcom.co.il/~choo/lupg/tutorials/index.html>] [Related) N
(Material <http://www.actcom.co.il/~choo/lupg/related-material.html>]) N
(multi-thread.txt) (Page 23/24) (Mar 27, 05 21:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
([Essays <http://www.actcom.co.il/~choo/lupg/essays/index.html>] [Project) p n
(Ideas <http://www.actcom.co.il/~choo/lupg/project-ideas/index.html>]) N
([Send Comments <mailto:choo@actcom.co.il>]) N
() N
(This document is copyright \(c\) 1998-2002 by guy keren.) N
() N
(The material in this document is provided AS IS, without any expressed) N
(or implied warranty, or claim of fitness for a particular purpose.) N
(Neither the author nor any contributers shell be liable for any damages) N
(incured directly or indirectly by using the material contained in this) N
(document.) N
() N
(permission to copy this document \(electronically or on paper, for) N
(personal or organization internal use\) or publish it on-line is hereby) N
(granted, provided that the document is copied as-is, this copyright) N
(notice is preserved, and a link to the original document is written in) N
(the document's body, or in the page linking to the copy of this document.) N
() N
(Permission to make translations of this document is also granted, under) N
(these terms - assuming the translation preserves the meaning of the) N
(text, the copyright notice is preserved as-is, and a link to the) N
(original document is written in the document's body, or in the page) N
(linking to the copy of this document.) N
() N
(For any questions about the document and its license, please contact the) N
(author <mailto:choo@actcom.co.il>.) N
() N
(multi-thread.txt) (Page 24/24) (Mar 27, 05 21:01) title
border
grestore
(Printed by root) rhead
(./multi-thread.txt) (12/12) (Sunday March 27, 2005) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
